{
  "examples": {
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\QueryExplanation.java Distance: 1 Line: 132 to 133": [
      "",
      "    @Override",
      "    public boolean equals(Object o) {",
      "        if (this == o) return true;",
      "        if (o == null || getClass() != o.getClass()) return false;",
      ">>> ",
      "        QueryExplanation other = (QueryExplanation) o;",
      "        return Objects.equals(getIndex(), other.getIndex())",
      "<<< ",
      "            && Objects.equals(getShard(), other.getShard())",
      "            && Objects.equals(isValid(), other.isValid())",
      "            && Objects.equals(getError(), other.getError())",
      "            && Objects.equals(getExplanation(), other.getExplanation());",
      "    }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeometryNormalizer.java Distance: 5 Line: 128 to 133": [
      "                }",
      "            }",
      "",
      "            @Override",
      "            public Geometry visit(MultiPolygon multiPolygon) {",
      ">>> ",
      "                List<Polygon> polygons = new ArrayList<>();",
      "                GeoPolygonDecomposer.decomposeMultiPolygon(multiPolygon, orientation.getAsBoolean(), polygons);",
      "                if (polygons.isEmpty()) {",
      "                    return MultiPolygon.EMPTY;",
      "                } else if (polygons.size() == 1) {",
      "                    return polygons.get(0);",
      "<<< ",
      "                } else {",
      "                    return new MultiPolygon(polygons);",
      "                }",
      "            }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\metadata\\MetadataIndexTemplateService.java Distance: 4 Line: 1213 to 1217": [
      "        PutRequest request,",
      "        IndexTemplateMetadata.Builder templateBuilder",
      "    ) {",
      "        // Flag for whether this is updating an existing template or adding a new one",
      "        // TODO: in 8.0+, only allow updating index templates, not adding new ones",
      ">>> ",
      "        boolean isUpdate = currentState.metadata().templates().containsKey(request.name);",
      "        if (request.create && isUpdate) {",
      "            throw new IllegalArgumentException(\"index_template [\" + request.name + \"] already exists\");",
      "        }",
      "        boolean isUpdateAndPatternsAreUnchanged = isUpdate",
      "<<< ",
      "            && currentState.metadata().templates().get(request.name).patterns().equals(request.indexPatterns);",
      "",
      "        Map<String, List<String>> overlaps = findConflictingV2Templates(currentState, request.name, request.indexPatterns);",
      "        if (overlaps.size() > 0) {",
      "            // Be less strict (just a warning) if we're updating an existing template or this is a match-all template"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 137 to 138": [
      "            routing = null;",
      "        } else {",
      "            // Random routing to limit request to a single shard",
      "            routing = Integer.toString(Randomness.get().nextInt(1000));",
      "        }",
      ">>> ",
      "        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, routing, request.indices());",
      "        return clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap, \"_local\");",
      "<<< ",
      "    }",
      "",
      "    @Override",
      "    protected ClusterBlockException checkGlobalBlock(ClusterState state, ValidateQueryRequest request) {",
      "        return state.blocks().globalBlockedException(ClusterBlockLevel.READ);"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeoFormatterFactory.java Distance: 5 Line: 73 to 78": [
      "        final int start = format.indexOf('(');",
      "        if (start == -1) {",
      "            return GeometryFormatterFactory.getFormatter(format, toGeometry);",
      "        }",
      "        final String formatName = format.substring(0, start);",
      ">>> ",
      "        Function<String, Function<List<T>, List<Object>>> factory = factories.get(formatName);",
      "        if (factory == null) {",
      "            throw new IllegalArgumentException(\"Invalid format: \" + formatName);",
      "        }",
      "        final String param = format.substring(start + 1, format.length() - 1);",
      "        return factory.apply(param);",
      "<<< ",
      "    }",
      "}"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\lucene\\search\\SpanBooleanQueryRewriteWithMaxClause.java Distance: 6 Line: 79 to 85": [
      "",
      "            private Collection<SpanQuery> collectTerms(IndexReader reader, MultiTermQuery query) throws IOException {",
      "                Set<SpanQuery> queries = new HashSet<>();",
      "                IndexReaderContext topReaderContext = reader.getContext();",
      "                for (LeafReaderContext context : topReaderContext.leaves()) {",
      ">>> ",
      "                    final Terms terms = context.reader().terms(query.getField());",
      "                    if (terms == null) {",
      "                        // field does not exist",
      "                        continue;",
      "                    }",
      "",
      "                    final TermsEnum termsEnum = getTermsEnum(query, terms, new AttributeSource());",
      "<<< ",
      "                    assert termsEnum != null;",
      "",
      "                    if (termsEnum == TermsEnum.EMPTY) {",
      "                        continue;",
      "                    }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\lucene\\search\\SpanBooleanQueryRewriteWithMaxClause.java Distance: 6 Line: 65 to 71": [
      "    @Override",
      "    public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {",
      "        final MultiTermQuery.RewriteMethod delegate = new MultiTermQuery.RewriteMethod() {",
      "            @Override",
      "            public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {",
      ">>> ",
      "                Collection<SpanQuery> queries = collectTerms(reader, query);",
      "                if (queries.size() == 0) {",
      "                    return new SpanMatchNoDocsQuery(query.getField(), \"no expansion found for \" + query.toString());",
      "                } else if (queries.size() == 1) {",
      "                    return queries.iterator().next();",
      "                } else {",
      "                    return new SpanOrQuery(queries.toArray(new SpanQuery[0]));",
      "<<< ",
      "                }",
      "            }",
      "",
      "            private Collection<SpanQuery> collectTerms(IndexReader reader, MultiTermQuery query) throws IOException {",
      "                Set<SpanQuery> queries = new HashSet<>();"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\metadata\\MetadataIndexTemplateService.java Distance: 4 Line: 1328 to 1332": [
      "        CollectionUtil.timSort(matchedTemplates, Comparator.comparingInt(IndexTemplateMetadata::order).reversed());",
      "",
      "        // this is complex but if the index is not hidden in the create request but is hidden as the result of template application,",
      "        // then we need to exclude global templates",
      "        if (isHidden == null) {",
      ">>> ",
      "            final Optional<IndexTemplateMetadata> templateWithHiddenSetting = matchedTemplates.stream()",
      "                .filter(template -> IndexMetadata.INDEX_HIDDEN_SETTING.exists(template.settings()))",
      "                .findFirst();",
      "            if (templateWithHiddenSetting.isPresent()) {",
      "                final boolean templatedIsHidden = IndexMetadata.INDEX_HIDDEN_SETTING.get(templateWithHiddenSetting.get().settings());",
      "<<< ",
      "                if (templatedIsHidden) {",
      "                    // remove the global templates",
      "                    matchedTemplates.removeIf(current -> current.patterns().stream().anyMatch(Regex::isMatchAllPattern));",
      "                }",
      "                // validate that hidden didn't change"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 93 to 94": [
      "        }, ex -> {",
      "            if (ex instanceof IndexNotFoundException || ex instanceof IndexClosedException) {",
      "                listener.onFailure(ex);",
      "                return;",
      "            }",
      ">>> ",
      "            List<QueryExplanation> explanations = new ArrayList<>();",
      "            explanations.add(new QueryExplanation(null, QueryExplanation.RANDOM_SHARD, false, null, ex.getMessage()));",
      "<<< ",
      "            listener.onResponse(",
      "                new ValidateQueryResponse(",
      "                    false,",
      "                    explanations,",
      "                    // totalShards is documented as \"the total shards this request ran against\","
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 173 to 174": [
      "                if (shardFailures == null) {",
      "                    shardFailures = new ArrayList<>();",
      "                }",
      "                shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException) shardResponse));",
      "            } else {",
      ">>> ",
      "                ShardValidateQueryResponse validateQueryResponse = (ShardValidateQueryResponse) shardResponse;",
      "                valid = valid && validateQueryResponse.isValid();",
      "<<< ",
      "                if (request.explain() || request.rewrite() || request.allShards()) {",
      "                    if (queryExplanations == null) {",
      "                        queryExplanations = new ArrayList<>();",
      "                    }",
      "                    queryExplanations.add("
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 119 to 120": [
      "",
      "    @Override",
      "    protected ShardValidateQueryRequest newShardRequest(int numShards, ShardRouting shard, ValidateQueryRequest request) {",
      "        final ClusterState clusterState = clusterService.state();",
      "        final Set<String> indicesAndAliases = indexNameExpressionResolver.resolveExpressions(clusterState, request.indices());",
      ">>> ",
      "        final AliasFilter aliasFilter = searchService.buildAliasFilter(clusterState, shard.getIndexName(), indicesAndAliases);",
      "        return new ShardValidateQueryRequest(shard.shardId(), aliasFilter, request);",
      "<<< ",
      "    }",
      "",
      "    @Override",
      "    protected ShardValidateQueryResponse readShardResponse(StreamInput in) throws IOException {",
      "        return new ShardValidateQueryResponse(in);"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\lucene\\search\\XMoreLikeThis.java Distance: 6 Line: 455 to 461": [
      "    /**",
      "     * Add to an existing boolean query the More Like This query from this PriorityQueue",
      "     */",
      "    private void addToQuery(PriorityQueue<ScoreTerm> q, BooleanQuery.Builder query) {",
      "        ScoreTerm scoreTerm;",
      ">>> ",
      "        float bestScore = -1;",
      "",
      "        while ((scoreTerm = q.pop()) != null) {",
      "            Query tq = new TermQuery(new Term(scoreTerm.topField, scoreTerm.word));",
      "",
      "            if (boost) {",
      "                if (bestScore == -1) {",
      "<<< ",
      "                    bestScore = (scoreTerm.score);",
      "                }",
      "                float myScore = (scoreTerm.score);",
      "                tq = new BoostQuery(tq, boostFactor * myScore / bestScore);",
      "            }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\metadata\\MetadataIndexTemplateService.java Distance: 4 Line: 871 to 875": [
      "                )",
      "            );",
      "    }",
      "",
      "    private void validateUseOfDeprecatedIngestPipelines(String name, IngestMetadata ingestMetadata, Settings combinedSettings) {",
      ">>> ",
      "        Map<String, PipelineConfiguration> pipelines = Optional.ofNullable(ingestMetadata)",
      "            .map(IngestMetadata::getPipelines)",
      "            .orElse(Map.of());",
      "        emitWarningIfPipelineIsDeprecated(name, pipelines, combinedSettings.get(\"index.default_pipeline\"));",
      "        emitWarningIfPipelineIsDeprecated(name, pipelines, combinedSettings.get(\"index.final_pipeline\"));",
      "<<< ",
      "    }",
      "",
      "    private void emitWarningIfPipelineIsDeprecated(String name, Map<String, PipelineConfiguration> pipelines, String pipelineName) {",
      "        Optional.ofNullable(pipelineName)",
      "            .map(pipelines::get)"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\metadata\\MetadataIndexTemplateService.java Distance: 4 Line: 943 to 947": [
      "        final Set<String> currentlyUnreferenced = findUnreferencedDataStreams.apply(state.metadata());",
      "",
      "        // Generate a metadata as if the new template were actually in the cluster state",
      "        final Metadata updatedMetadata = Metadata.builder(state.metadata()).put(templateName, newTemplate).build();",
      "        // Find the data streams that would be unreferenced now that the template is updated/added",
      ">>> ",
      "        final Set<String> newlyUnreferenced = findUnreferencedDataStreams.apply(updatedMetadata);",
      "",
      "        // If we found any data streams that used to be covered, but will no longer be covered by",
      "        // changing this template, then blow up with as much helpful information as we can muster",
      "        if (newlyUnreferenced.size() > currentlyUnreferenced.size()) {",
      "<<< ",
      "            throw new IllegalArgumentException(",
      "                \"composable template [\"",
      "                    + templateName",
      "                    + \"] with index patterns \"",
      "                    + newTemplate.indexPatterns()"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeoLineDecomposer.java Distance: 5 Line: 98 to 103": [
      "                shift = newShift;",
      "                double t = intersection(lons[i - 1] + shift, lons[i] + shift);",
      "                if (Double.isNaN(t) == false) {",
      "                    // Found intersection, all previous segments are now part of the linestring",
      "                    double[] partLons = Arrays.copyOfRange(lons, offset, i + 1);",
      ">>> ",
      "                    double[] partLats = Arrays.copyOfRange(lats, offset, i + 1);",
      "                    lons[i - 1] = partLons[partLons.length - 1] = (direction > 0 ? DATELINE : -DATELINE) - shift;",
      "                    lats[i - 1] = partLats[partLats.length - 1] = lats[i - 1] + (lats[i] - lats[i - 1]) * t;",
      "                    performShift(shift, partLons);",
      "                    offset = i - 1;",
      "                    collector.add(new Line(partLons, partLats));",
      "<<< ",
      "                } else {",
      "                    // Didn't find intersection - just continue checking",
      "                    i++;",
      "                }",
      "            }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeometryNormalizer.java Distance: 5 Line: 148 to 153": [
      "                return new Point(latlon[0], latlon[1]);",
      "            }",
      "",
      "            @Override",
      "            public Geometry visit(Polygon polygon) {",
      ">>> ",
      "                List<Polygon> polygons = new ArrayList<>();",
      "                GeoPolygonDecomposer.decomposePolygon(polygon, orientation.getAsBoolean(), polygons);",
      "                if (polygons.isEmpty()) {",
      "                    return Polygon.EMPTY;",
      "                } else if (polygons.size() == 1) {",
      "                    return polygons.get(0);",
      "<<< ",
      "                } else {",
      "                    return new MultiPolygon(polygons);",
      "                }",
      "            }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeoLineDecomposer.java Distance: 5 Line: 85 to 90": [
      "            int direction = Double.compare(lons[i], lons[i - 1]);",
      "            double newShift = calculateShift(lons[i - 1], direction < 0);",
      "            // first point lon + shift is always between -180.0 and +180.0",
      "            if (i - offset > 1 && newShift != shift) {",
      "                // Jumping over anti-meridian - we need to start a new segment",
      ">>> ",
      "                double[] partLons = Arrays.copyOfRange(lons, offset, i);",
      "                double[] partLats = Arrays.copyOfRange(lats, offset, i);",
      "                performShift(shift, partLons);",
      "                shift = newShift;",
      "                offset = i - 1;",
      "                collector.add(new Line(partLons, partLats));",
      "<<< ",
      "            } else {",
      "                // Check if new point intersects with anti-meridian",
      "                shift = newShift;",
      "                double t = intersection(lons[i - 1] + shift, lons[i] + shift);",
      "                if (Double.isNaN(t) == false) {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 118 to 119": [
      "    }",
      "",
      "    @Override",
      "    protected ShardValidateQueryRequest newShardRequest(int numShards, ShardRouting shard, ValidateQueryRequest request) {",
      "        final ClusterState clusterState = clusterService.state();",
      ">>> ",
      "        final Set<String> indicesAndAliases = indexNameExpressionResolver.resolveExpressions(clusterState, request.indices());",
      "        final AliasFilter aliasFilter = searchService.buildAliasFilter(clusterState, shard.getIndexName(), indicesAndAliases);",
      "<<< ",
      "        return new ShardValidateQueryRequest(shard.shardId(), aliasFilter, request);",
      "    }",
      "",
      "    @Override",
      "    protected ShardValidateQueryResponse readShardResponse(StreamInput in) throws IOException {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\validate\\query\\TransportValidateQueryAction.java Distance: 1 Line: 117 to 118": [
      "        }",
      "    }",
      "",
      "    @Override",
      "    protected ShardValidateQueryRequest newShardRequest(int numShards, ShardRouting shard, ValidateQueryRequest request) {",
      ">>> ",
      "        final ClusterState clusterState = clusterService.state();",
      "        final Set<String> indicesAndAliases = indexNameExpressionResolver.resolveExpressions(clusterState, request.indices());",
      "<<< ",
      "        final AliasFilter aliasFilter = searchService.buildAliasFilter(clusterState, shard.getIndexName(), indicesAndAliases);",
      "        return new ShardValidateQueryRequest(shard.shardId(), aliasFilter, request);",
      "    }",
      "",
      "    @Override"
    ]
  },
  "double_declaration_examples": {
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\hash\\MurmurHash3.java Distance: 1 Line: 129 to 130": [
      "",
      "            h1 = Long.rotateLeft(h1, 27);",
      "            h1 += h2;",
      "            h1 = h1 * 5 + 0x52dce729;",
      "",
      ">>> ",
      "            k2 *= C2;",
      "            k2 = Long.rotateLeft(k2, 33);",
      "<<< ",
      "            k2 *= C1;",
      "            h2 ^= k2;",
      "",
      "            h2 = Long.rotateLeft(h2, 31);",
      "            h2 += h1;"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\index\\mapper\\vectors\\SparseVectorFieldMapper.java Distance: 6 Line: 173 to 179": [
      "            throw new IllegalArgumentException(",
      "                \"[sparse_vector] fields must be json objects, expected a START_OBJECT but got: \" + context.parser().currentToken()",
      "            );",
      "        }",
      "",
      ">>> ",
      "        String feature = null;",
      "        try {",
      "            // make sure that we don't expand dots in field names while parsing",
      "            context.path().setWithinLeafObject(true);",
      "            for (Token token = context.parser().nextToken(); token != Token.END_OBJECT; token = context.parser().nextToken()) {",
      "                if (token == Token.FIELD_NAME) {",
      "                    feature = context.parser().currentName();",
      "<<< ",
      "                    if (feature.contains(\".\")) {",
      "                        throw new IllegalArgumentException(",
      "                            \"[sparse_vector] fields do not support dots in feature names but found [\" + feature + \"]\"",
      "                        );",
      "                    }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\mapping\\get\\TransportGetFieldMappingsIndexAction.java Distance: 4 Line: 162 to 166": [
      "        // TODO the logic here needs to be reworked to also include runtime fields. Though matching is against mappers rather",
      "        // than field types, and runtime fields are mixed with ordinary fields in FieldTypeLookup",
      "        Map<String, FieldMappingMetadata> fieldMappings = new HashMap<>();",
      "        for (String field : request.fields()) {",
      "            if (Regex.isMatchAllPattern(field)) {",
      ">>> ",
      "                for (Mapper fieldMapper : mappingLookup.fieldMappers()) {",
      "                    addFieldMapper(fieldPredicate, fieldMapper.name(), fieldMapper, fieldMappings, request.includeDefaults());",
      "                }",
      "            } else if (Regex.isSimpleMatchPattern(field)) {",
      "                for (Mapper fieldMapper : mappingLookup.fieldMappers()) {",
      "<<< ",
      "                    if (Regex.simpleMatch(field, fieldMapper.name())) {",
      "                        addFieldMapper(fieldPredicate, fieldMapper.name(), fieldMapper, fieldMappings, request.includeDefaults());",
      "                    }",
      "                }",
      "            } else {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\index\\query\\functionscore\\DecayFunctionParser.java Distance: 6 Line: 89 to 95": [
      "     * </code>",
      "     * </pre>",
      "     */",
      "    @Override",
      "    public DFB fromXContent(XContentParser parser) throws IOException, ParsingException {",
      ">>> ",
      "        String currentFieldName;",
      "        XContentParser.Token token;",
      "        MultiValueMode multiValueMode = DecayFunctionBuilder.DEFAULT_MULTI_VALUE_MODE;",
      "        String fieldName = null;",
      "        BytesReference functionBytes = null;",
      "        while ((token = parser.nextToken()) == XContentParser.Token.FIELD_NAME) {",
      "            currentFieldName = parser.currentName();",
      "<<< ",
      "            token = parser.nextToken();",
      "            if (token == XContentParser.Token.START_OBJECT) {",
      "                fieldName = currentFieldName;",
      "                XContentBuilder builder = XContentFactory.jsonBuilder();",
      "                builder.copyCurrentStructure(parser);"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\GeoLineDecomposer.java Distance: 1 Line: 99 to 100": [
      "                double t = intersection(lons[i - 1] + shift, lons[i] + shift);",
      "                if (Double.isNaN(t) == false) {",
      "                    // Found intersection, all previous segments are now part of the linestring",
      "                    double[] partLons = Arrays.copyOfRange(lons, offset, i + 1);",
      "                    double[] partLats = Arrays.copyOfRange(lats, offset, i + 1);",
      ">>> ",
      "                    lons[i - 1] = partLons[partLons.length - 1] = (direction > 0 ? DATELINE : -DATELINE) - shift;",
      "                    lats[i - 1] = partLats[partLats.length - 1] = lats[i - 1] + (lats[i] - lats[i - 1]) * t;",
      "<<< ",
      "                    performShift(shift, partLons);",
      "                    offset = i - 1;",
      "                    collector.add(new Line(partLons, partLats));",
      "                } else {",
      "                    // Didn't find intersection - just continue checking"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\breaker\\ChildMemoryCircuitBreaker.java Distance: 1 Line: 132 to 133": [
      "        }",
      "        assert newUsed >= 0 : \"Used bytes: [\" + newUsed + \"] must be >= 0\";",
      "    }",
      "",
      "    private long noLimit(long bytes, String label) {",
      ">>> ",
      "        long newUsed;",
      "        newUsed = this.used.addAndGet(bytes);",
      "<<< ",
      "        logger.trace(",
      "            () -> format(",
      "                \"[%s] Adding [%s][%s] to used bytes [new used: [%s], limit: [-1b]]\",",
      "                this.name,",
      "                ByteSizeValue.ofBytes(bytes),"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\routing\\IndexRoutingTable.java Distance: 1 Line: 330 to 331": [
      "        return Arrays.equals(shards, that.shards);",
      "    }",
      "",
      "    @Override",
      "    public int hashCode() {",
      ">>> ",
      "        int result = index.hashCode();",
      "        result = 31 * result + Arrays.hashCode(shards);",
      "<<< ",
      "        return result;",
      "    }",
      "",
      "    public static IndexRoutingTable readFrom(StreamInput in) throws IOException {",
      "        Index index = new Index(in);"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\index\\query\\functionscore\\DecayFunctionParser.java Distance: 6 Line: 92 to 98": [
      "    @Override",
      "    public DFB fromXContent(XContentParser parser) throws IOException, ParsingException {",
      "        String currentFieldName;",
      "        XContentParser.Token token;",
      "        MultiValueMode multiValueMode = DecayFunctionBuilder.DEFAULT_MULTI_VALUE_MODE;",
      ">>> ",
      "        String fieldName = null;",
      "        BytesReference functionBytes = null;",
      "        while ((token = parser.nextToken()) == XContentParser.Token.FIELD_NAME) {",
      "            currentFieldName = parser.currentName();",
      "            token = parser.nextToken();",
      "            if (token == XContentParser.Token.START_OBJECT) {",
      "                fieldName = currentFieldName;",
      "<<< ",
      "                XContentBuilder builder = XContentFactory.jsonBuilder();",
      "                builder.copyCurrentStructure(parser);",
      "                functionBytes = BytesReference.bytes(builder);",
      "            } else if (MULTI_VALUE_MODE.match(currentFieldName, parser.getDeprecationHandler())) {",
      "                multiValueMode = MultiValueMode.fromString(parser.text());"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\shrink\\ResizeNumberOfShardsCalculator.java Distance: 4 Line: 102 to 106": [
      "",
      "        @Override",
      "        public void validate(int numberOfShards, IndexMetadata sourceMetadata) {",
      "            for (int i = 0; i < numberOfShards; i++) {",
      "                Set<ShardId> shardIds = IndexMetadata.selectShrinkShards(i, sourceMetadata, numberOfShards);",
      ">>> ",
      "                long count = 0;",
      "                for (ShardId shardId : shardIds) {",
      "                    DocsStats docsStats = perShardDocStats.apply(shardId.id());",
      "                    if (docsStats != null) {",
      "                        count += docsStats.getCount();",
      "<<< ",
      "                    }",
      "                    if (count > IndexWriter.MAX_DOCS) {",
      "                        throw new IllegalStateException(",
      "                            \"Can't merge index with more than [\"",
      "                                + IndexWriter.MAX_DOCS"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\cluster\\stats\\TransportClusterStatsAction.java Distance: 4 Line: 207 to 211": [
      "            for (IndexShard indexShard : indexService) {",
      "                cancellableTask.ensureNotCancelled();",
      "                if (indexShard.routingEntry() != null && indexShard.routingEntry().active()) {",
      "                    // only report on fully started shards",
      "                    CommitStats commitStats;",
      ">>> ",
      "                    SeqNoStats seqNoStats;",
      "                    RetentionLeaseStats retentionLeaseStats;",
      "                    try {",
      "                        commitStats = indexShard.commitStats();",
      "                        seqNoStats = indexShard.seqNoStats();",
      "<<< ",
      "                        retentionLeaseStats = indexShard.getRetentionLeaseStats();",
      "                    } catch (final AlreadyClosedException e) {",
      "                        // shard is closed - no stats is fine",
      "                        commitStats = null;",
      "                        seqNoStats = null;"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\cluster\\stats\\TransportClusterStatsAction.java Distance: 4 Line: 206 to 210": [
      "        for (IndexService indexService : indicesService) {",
      "            for (IndexShard indexShard : indexService) {",
      "                cancellableTask.ensureNotCancelled();",
      "                if (indexShard.routingEntry() != null && indexShard.routingEntry().active()) {",
      "                    // only report on fully started shards",
      ">>> ",
      "                    CommitStats commitStats;",
      "                    SeqNoStats seqNoStats;",
      "                    RetentionLeaseStats retentionLeaseStats;",
      "                    try {",
      "                        commitStats = indexShard.commitStats();",
      "<<< ",
      "                        seqNoStats = indexShard.seqNoStats();",
      "                        retentionLeaseStats = indexShard.getRetentionLeaseStats();",
      "                    } catch (final AlreadyClosedException e) {",
      "                        // shard is closed - no stats is fine",
      "                        commitStats = null;"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\index\\query\\GeoPolygonQueryBuilder.java Distance: 6 Line: 246 to 252": [
      "        List<GeoPoint> shell = null;",
      "",
      "        Float boost = null;",
      "        GeoValidationMethod validationMethod = null;",
      "        String queryName = null;",
      ">>> ",
      "        String currentFieldName = null;",
      "        XContentParser.Token token;",
      "        boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED;",
      "",
      "        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {",
      "            if (token == XContentParser.Token.FIELD_NAME) {",
      "                currentFieldName = parser.currentName();",
      "<<< ",
      "            } else if (token == XContentParser.Token.START_OBJECT) {",
      "                fieldName = currentFieldName;",
      "",
      "                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {",
      "                    if (token == XContentParser.Token.FIELD_NAME) {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\index\\mapper\\IpPrefixAutomatonUtil.java Distance: 6 Line: 86 to 92": [
      "",
      "    private static Automaton getIpv6Automaton(String ipPrefix) {",
      "        Automaton ipv6Automaton = EMPTY_AUTOMATON;",
      "        List<String> ip6Groups = parseIp6Prefix(ipPrefix);",
      "        if (ip6Groups.isEmpty() == false) {",
      ">>> ",
      "            ipv6Automaton = Automata.makeString(\"\");",
      "            int groupsAdded = 0;",
      "            for (String group : ip6Groups) {",
      "                if (group.contains(\".\")) {",
      "                    // try to parse this as ipv4 ending part, but only if we already have some ipv6 specific stuff in front",
      "                    if (groupsAdded > 0) {",
      "                        ipv6Automaton = concatenate(ipv6Automaton, createIp4Automaton(group));",
      "<<< ",
      "                        groupsAdded += 2; // this counts as two bytes, missing bytes are padded already",
      "                    } else {",
      "                        return EMPTY_AUTOMATON;",
      "                    }",
      "                } else if (group.endsWith(\":\")) {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\hash\\MurmurHash3.java Distance: 1 Line: 87 to 88": [
      "",
      "    protected static long fmix(long k) {",
      "        k ^= k >>> 33;",
      "        k *= 0xff51afd7ed558ccdL;",
      "        k ^= k >>> 33;",
      ">>> ",
      "        k *= 0xc4ceb9fe1a85ec53L;",
      "        k ^= k >>> 33;",
      "<<< ",
      "        return k;",
      "    }",
      "",
      "    /**",
      "     * Compute the hash of the MurmurHash3_x64_128 hashing function."
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\action\\admin\\indices\\settings\\get\\TransportGetSettingsAction.java Distance: 4 Line: 98 to 102": [
      "                continue;",
      "            }",
      "",
      "            Settings indexSettings = settingsFilter.filter(indexMetadata.getSettings());",
      "            if (request.humanReadable()) {",
      ">>> ",
      "                indexSettings = IndexMetadata.addHumanReadableSettings(indexSettings);",
      "            }",
      "",
      "            if (isFilteredRequest(request)) {",
      "                indexSettings = indexSettings.filter(k -> Regex.simpleMatch(request.names(), k));",
      "<<< ",
      "            }",
      "",
      "            indexToSettings.put(concreteIndex.getName(), indexSettings);",
      "            if (indexToDefaultSettings != null) {",
      "                Settings defaultSettings = settingsFilter.filter(indexScopedSettings.diff(indexSettings, Settings.EMPTY));"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\geo\\SimpleFeatureFactory.java Distance: 1 Line: 78 to 79": [
      "            if (posLat > extent || posLat < 0) {",
      "                continue;",
      "            }",
      "            // filter out repeated points",
      "            if (numPoints == 0 || posLon != prevLon || posLat != prevLat) {",
      ">>> ",
      "                commands[pos++] = BitUtil.zigZagEncode(posLon - prevLon);",
      "                commands[pos++] = BitUtil.zigZagEncode(posLat - prevLat);",
      "<<< ",
      "                prevLon = posLon;",
      "                prevLat = posLat;",
      "                numPoints++;",
      "            }",
      "        }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\cluster\\routing\\Murmur3HashFunction.java Distance: 1 Line: 28 to 29": [
      "        final byte[] bytesToHash = new byte[routing.length() * 2];",
      "        for (int i = 0; i < routing.length(); ++i) {",
      "            final char c = routing.charAt(i);",
      "            final byte b1 = (byte) c, b2 = (byte) (c >>> 8);",
      "            assert ((b1 & 0xFF) | ((b2 & 0xFF) << 8)) == c; // no information loss",
      ">>> ",
      "            bytesToHash[i * 2] = b1;",
      "            bytesToHash[i * 2 + 1] = b2;",
      "<<< ",
      "        }",
      "        return hash(bytesToHash, 0, bytesToHash.length);",
      "    }",
      "",
      "    public static int hash(byte[] bytes, int offset, int length) {"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\compress\\CompressedXContent.java Distance: 5 Line: 209 to 214": [
      "",
      "    public static CompressedXContent readCompressedString(StreamInput in) throws IOException {",
      "        final String sha256;",
      "        final byte[] compressedData;",
      "        if (in.getTransportVersion().onOrAfter(TransportVersions.V_8_0_0)) {",
      ">>> ",
      "            sha256 = in.readString();",
      "            compressedData = in.readByteArray();",
      "        } else {",
      "            int crc32 = in.readInt();",
      "            compressedData = in.readByteArray();",
      "            sha256 = sha256FromCompressed(compressedData);",
      "<<< ",
      "        }",
      "        return new CompressedXContent(compressedData, sha256);",
      "    }",
      "",
      "    @Override"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\hash\\MurmurHash3.java Distance: 1 Line: 85 to 86": [
      "    private static long C1 = 0x87c37b91114253d5L;",
      "    private static long C2 = 0x4cf5ad432745937fL;",
      "",
      "    protected static long fmix(long k) {",
      "        k ^= k >>> 33;",
      ">>> ",
      "        k *= 0xff51afd7ed558ccdL;",
      "        k ^= k >>> 33;",
      "<<< ",
      "        k *= 0xc4ceb9fe1a85ec53L;",
      "        k ^= k >>> 33;",
      "        return k;",
      "    }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\compress\\DeflateCompressor.java Distance: 5 Line: 138 to 143": [
      "        if (len != HEADER.length || Arrays.equals(headerBytes, HEADER) == false) {",
      "            throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");",
      "        }",
      "",
      "        final Releasable releasable;",
      ">>> ",
      "        final Inflater inflater;",
      "        if (threadLocal) {",
      "            final ReleasableReference<Inflater> current = inflaterForStreamRef.get();",
      "            if (current.inUse) {",
      "                // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater",
      "                inflater = new Inflater(true);",
      "<<< ",
      "                releasable = inflater::end;",
      "            } else {",
      "                inflater = current.get();",
      "                releasable = current;",
      "            }"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\hash\\MurmurHash3.java Distance: 1 Line: 120 to 121": [
      "        final int end = offset + len16;",
      "        for (int i = offset; i < end; i += 16) {",
      "            long k1 = ByteUtils.readLongLE(key, i);",
      "            long k2 = ByteUtils.readLongLE(key, i + 8);",
      "",
      ">>> ",
      "            k1 *= C1;",
      "            k1 = Long.rotateLeft(k1, 31);",
      "<<< ",
      "            k1 *= C2;",
      "            h1 ^= k1;",
      "",
      "            h1 = Long.rotateLeft(h1, 27);",
      "            h1 += h2;"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\breaker\\PreallocatedCircuitBreakerService.java Distance: 5 Line: 141 to 146": [
      "                return;",
      "            }",
      "            long newUsed = preallocationUsed + bytes;",
      "            if (newUsed > preallocated) {",
      "                // This request filled up the buffer",
      ">>> ",
      "                preallocationUsed = preallocated;",
      "                next.addWithoutBreaking(newUsed - preallocated);",
      "                return;",
      "            }",
      "            // This is the fast case. No volatile reads or writes here, ma!",
      "            preallocationUsed = newUsed;",
      "<<< ",
      "        }",
      "",
      "        @Override",
      "        public String getName() {",
      "            return next.getName();"
    ],
    "elasticsearch\\server\\src\\main\\java\\org\\elasticsearch\\common\\hash\\MessageDigests.java Distance: 1 Line: 122 to 123": [
      "    public static char[] toHexCharArray(byte[] bytes) {",
      "        Objects.requireNonNull(bytes);",
      "        final char[] result = new char[2 * bytes.length];",
      "        for (int i = 0; i < bytes.length; i++) {",
      "            byte b = bytes[i];",
      ">>> ",
      "            result[2 * i] = HEX_DIGITS[b >> 4 & 0xf];",
      "            result[2 * i + 1] = HEX_DIGITS[b & 0xf];",
      "<<< ",
      "        }",
      "        return result;",
      "    }",
      "",
      "    /**"
    ]
  }
}