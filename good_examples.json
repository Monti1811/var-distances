{
      "druid\\core\\src\\main\\java\\com\\alibaba\\druid\\pool\\DruidDataSource.java Distance: 25 Line: 1952 to 1977": [
            "    protected final void handleFatalError(",
            "            DruidPooledConnection conn,",
            "            SQLException error,",
            "            String sql",
            "    ) throws SQLException {",
            ">>> var: holder",
            "        final DruidConnectionHolder holder = conn.holder;",
            "",
            "        if (conn.isTraceEnable()) {",
            "            activeConnectionLock.lock();",
            "            try {",
            "                if (conn.isTraceEnable()) {",
            "                    activeConnections.remove(conn);",
            "                    conn.setTraceEnable(false);",
            "                }",
            "            } finally {",
            "                activeConnectionLock.unlock();",
            "            }",
            "        }",
            "",
            "        long lastErrorTimeMillis = this.lastErrorTimeMillis;",
            "        if (lastErrorTimeMillis == 0) {",
            "            lastErrorTimeMillis = System.currentTimeMillis();",
            "        }",
            "",
            "        if (sql != null && sql.length() > 1024) {",
            "            sql = sql.substring(0, 1024);",
            "        }",
            "",
            "        boolean requireDiscard = false;",
            "        // using dataSourceLock when holder dataSource isn't null because shrink used it to access fatal error variables.",
            "        boolean hasHolderDataSource = (holder != null && holder.getDataSource() != null);",
            "<<< var: holder",
            "        ReentrantLock fatalErrorCountLock = hasHolderDataSource ? holder.getDataSource().lock : conn.lock;",
            "        fatalErrorCountLock.lock();",
            "        try {",
            "            if ((!conn.closed) && !conn.disable) {",
            "                conn.disable(error);"
      ],
      "druid\\core\\src\\main\\java\\com\\alibaba\\druid\\sql\\ast\\statement\\SQLCreateTableStatement.java Distance: 25 Line: 709 to 734": [
            "        return stmt;",
            "    }",
            "",
            "    public static void sort(List<SQLStatement> stmtList) {",
            "        Map<String, SQLCreateTableStatement> tables = new HashMap<String, SQLCreateTableStatement>();",
            ">>> var: referencedTables",
            "        Map<String, List<SQLCreateTableStatement>> referencedTables = new HashMap<String, List<SQLCreateTableStatement>>();",
            "",
            "        for (SQLStatement stmt : stmtList) {",
            "            if (stmt instanceof SQLCreateTableStatement) {",
            "                SQLCreateTableStatement createTableStmt = (SQLCreateTableStatement) stmt;",
            "                String tableName = createTableStmt.getName().getSimpleName();",
            "                tableName = SQLUtils.normalize(tableName).toLowerCase();",
            "                tables.put(tableName, createTableStmt);",
            "            }",
            "        }",
            "",
            "        List<ListDG.Edge> edges = new ArrayList<ListDG.Edge>();",
            "",
            "        for (SQLCreateTableStatement stmt : tables.values()) {",
            "            for (SQLTableElement element : stmt.getTableElementList()) {",
            "                if (element instanceof SQLForeignKeyConstraint) {",
            "                    SQLForeignKeyConstraint fk = (SQLForeignKeyConstraint) element;",
            "                    String refTableName = fk.getReferencedTableName().getSimpleName();",
            "                    refTableName = SQLUtils.normalize(refTableName).toLowerCase();",
            "",
            "                    SQLCreateTableStatement refTable = tables.get(refTableName);",
            "                    if (refTable != null) {",
            "                        edges.add(new ListDG.Edge(stmt, refTable));",
            "                    }",
            "",
            "                    List<SQLCreateTableStatement> referencedList = referencedTables.get(refTableName);",
            "<<< var: referencedTables",
            "                    if (referencedList == null) {",
            "                        referencedList = new ArrayList<SQLCreateTableStatement>();",
            "                        referencedTables.put(refTableName, referencedList);",
            "                    }",
            "                    referencedList.add(stmt);"
      ],
      "jenkins\\core\\src\\main\\java\\jenkins\\model\\Jenkins.java Distance: 30 Line: 3486 to 3516": [
            "                throw new IOException(projectsDir + \" is not a directory\");",
            "            throw new IOException(\"Unable to create \" + projectsDir + \"\\nPermission issue? Please create this directory manually.\");",
            "        }",
            "        File[] subdirs = projectsDir.listFiles();",
            "",
            ">>> var: loadedNames",
            "        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<>());",
            "",
            "        TaskGraphBuilder g = new TaskGraphBuilder();",
            "        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(SYSTEM_CONFIG_LOADED).add(\"Loading global config\", new Executable() {",
            "            @Override",
            "            public void run(Reactor session) throws Exception {",
            "                load();",
            "                // if we are loading old data that doesn't have this field",
            "                if (slaves != null && !slaves.isEmpty() && nodes.isLegacy()) {",
            "                    nodes.setNodes(slaves);",
            "                    slaves = null;",
            "                } else {",
            "                    nodes.load();",
            "                }",
            "",
            "                clouds.setOwner(Jenkins.this);",
            "            }",
            "        });",
            "",
            "        List<Handle> loadJobs = new ArrayList<>();",
            "        for (final File subdir : subdirs) {",
            "            loadJobs.add(g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(\"Loading item \" + subdir.getName(), new Executable() {",
            "                @Override",
            "                public void run(Reactor session) throws Exception {",
            "                    if (!Items.getConfigFile(subdir).exists()) {",
            "                        //Does not have job config file, so it is not a jenkins job hence skip it",
            "                        return;",
            "                    }",
            "                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);",
            "                    items.put(item.getName(), item);",
            "                    loadedNames.add(item.getName());",
            "<<< var: loadedNames",
            "                }",
            "            }));",
            "        }",
            "",
            "        g.requires(loadJobs.toArray(new Handle[0])).attains(JOB_LOADED).add(\"Cleaning up obsolete items deleted from the disk\", new Executable() {"
      ],
      "jenkins\\core\\src\\main\\java\\jenkins\\util\\xstream\\XStreamDOM.java Distance: 20 Line: 543 to 563": [
            "            r.moveUp();",
            "            return dom;",
            "        }",
            "",
            "        public XStreamDOM unmarshalElement(HierarchicalStreamReader r, UnmarshallingContext context) {",
            ">>> var: name",
            "            String name = escape(r.getNodeName());",
            "",
            "            int c = r.getAttributeCount();",
            "            String[] attributes = new String[c * 2];",
            "            for (int i = 0; i < c; i++) {",
            "                attributes[i * 2]   = escape(r.getAttributeName(i));",
            "                attributes[i * 2 + 1] = r.getAttribute(i);",
            "            }",
            "",
            "            List<XStreamDOM> children = null;",
            "            String value = null;",
            "            if (r.hasMoreChildren()) {",
            "                children = new ArrayList<>();",
            "                while (r.hasMoreChildren()) {",
            "                    children.add(unmarshal(r, context));",
            "                }",
            "            } else {",
            "                value = r.getValue();",
            "            }",
            "",
            "            return new XStreamDOM(name, attributes, children, value);",
            "<<< var: name",
            "        }",
            "    }",
            "",
            "    @Restricted(NoExternalUse.class)",
            "    @RestrictedSince(\"2.301\")"
      ],
      "mindustry\\annotations\\src\\main\\java\\mindustry\\annotations\\entity\\EntityProcess.java Distance: 15 Line: 269 to 284": [
            "                    err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses, type);",
            "                }",
            "",
            "                //get base class type name for extension",
            "                Stype baseClassType = baseClasses.any() ? baseClasses.first() : null;",
            ">>> var: baseClass",
            "                @Nullable TypeName baseClass = baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;",
            "                @Nullable TypeSpec.Builder baseClassBuilder = baseClassType == null ? null : this.baseClasses.find(b -> Reflect.<String>get(b, \"name\").equals(baseName(baseClassType)));",
            "                boolean addIndexToBase = baseClassBuilder != null && baseClassIndexers.add(baseClassBuilder);",
            "                //whether the main class is the base itself",
            "                boolean typeIsBase = baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();",
            "",
            "                if(type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))){",
            "                    err(\"All entity def names must end with 'Def'/'Comp'\", type.e);",
            "                }",
            "",
            "                String name = type.isType() ?",
            "                    type.name().replace(\"Def\", \"\").replace(\"Comp\", \"\") :",
            "                    createName(type);",
            "",
            "                //check for type name conflicts",
            "                if(!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))){",
            "<<< var: baseClass",
            "                    name += \"Entity\";",
            "                }",
            "",
            "                boolean legacy = ann.legacy();"
      ],
      "fastjson\\src\\main\\java\\com\\alibaba\\fastjson\\asm\\ClassReader.java Distance: 30 Line: 190 to 220": [
            "        int v;",
            "        int w;",
            "        int j;",
            "        String attrName;",
            "        int k;",
            ">>> var: access",
            "        int access = readUnsignedShort(u);",
            "        String name = readUTF8(u + 2, c);",
            "        String desc = readUTF8(u + 4, c);",
            "        v = 0;",
            "        w = 0;",
            "",
            "        // looks for Code and Exceptions attributes",
            "        j = readUnsignedShort(u + 6);",
            "        u += 8;",
            "        for (; j > 0; --j) {",
            "            attrName = readUTF8(u, c);",
            "            int attrSize = readInt(u + 2);",
            "            u += 6;",
            "            // tests are sorted in decreasing frequency order",
            "            // (based on frequencies observed on typical classes)",
            "            if (attrName.equals(\"Code\")) {",
            "                v = u;",
            "            }",
            "            u += attrSize;",
            "        }",
            "        // reads declared exceptions",
            "        if (w == 0) {",
            "        } else {",
            "            w += 2;",
            "            for (j = 0; j < readUnsignedShort(w); ++j) {",
            "                w += 2;",
            "            }",
            "        }",
            "",
            "        // visits the method's code, if any",
            "        MethodCollector mv = classVisitor.visitMethod(access, name, desc);",
            "<<< var: access",
            "",
            "        if (mv != null && v != 0) {",
            "            int codeLength = readInt(v + 4);",
            "            v += 8;"
      ],
      "fastjson\\src\\main\\java\\com\\alibaba\\fastjson\\parser\\DefaultJSONParser.java Distance: 15 Line: 550 to 565": [
            "                        throw new JSONException(\"syntax error\");",
            "                    }",
            "                } else if (ch == '{') { // å‡�å°‘åµŒå¥—ï¼Œå…¼å®¹ Android",
            "                    lexer.nextToken();",
            "",
            ">>> var: parentIsArray",
            "                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;",
            "",
            "                    Map input;",
            "                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {",
            "                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);",
            "",
            "",
            "                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0",
            "                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())",
            "                                : mapDeserializer.createMap(Map.class);",
            "                    } else {",
            "                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));",
            "                    }",
            "                    ParseContext ctxLocal = null;",
            "",
            "                    if (!parentIsArray) {",
            "<<< var: parentIsArray",
            "                        ctxLocal = setContext(this.context, input, key);",
            "                    }",
            "",
            "                    Object obj = null;",
            "                    boolean objParsed = false;"
      ],
      "fastjson\\src\\main\\java\\com\\alibaba\\fastjson\\parser\\deserializer\\JavaBeanDeserializer.java Distance: 15 Line: 1384 to 1399": [
            "        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {",
            "            object = createInstance(null, clazz);",
            "            ",
            "            for (Map.Entry<String, Object> entry : map.entrySet()) {",
            "                String key = entry.getKey();",
            ">>> var: value",
            "                Object value = entry.getValue();",
            "",
            "                FieldDeserializer fieldDeser = smartMatch(key);",
            "                if (fieldDeser == null) {",
            "                    continue;",
            "                }",
            "",
            "                final FieldInfo fieldInfo = fieldDeser.fieldInfo;",
            "                Field field = fieldDeser.fieldInfo.field;",
            "                Type paramType = fieldInfo.fieldType;",
            "",
            "                Class<?> fieldClass = fieldInfo.fieldClass;",
            "                JSONField fieldAnnation = fieldInfo.getAnnotation();",
            "",
            "                if (fieldInfo.declaringClass != null",
            "                        && ((!fieldClass.isInstance(value))",
            "<<< var: value",
            "                            || (fieldAnnation != null && fieldAnnation.deserializeUsing() != Void.class))",
            "                ) {",
            "                    String input;",
            "                    if (value instanceof String",
            "                            && JSONValidator.from(((String) value))"
      ],
      "skywalking\\oap-server\\analyzer\\agent-analyzer\\src\\main\\java\\org\\apache\\skywalking\\oap\\server\\analyzer\\provider\\trace\\parser\\listener\\SegmentAnalysisListener.java Distance: 10 Line: 87 to 97": [
            "                serviceName,",
            "                true",
            "            );",
            "        }",
            "",
            ">>> var: timeBucket",
            "        long timeBucket = TimeBucket.getRecordTimeBucket(startTimestamp);",
            "",
            "        segment.setSegmentId(segmentObject.getTraceSegmentId());",
            "        segment.setServiceId(serviceId);",
            "        segment.setServiceInstanceId(IDManager.ServiceInstanceID.buildId(",
            "            serviceId,",
            "            namingControl.formatInstanceName(segmentObject.getServiceInstance())",
            "        ));",
            "        segment.setLatency(duration);",
            "        segment.setStartTime(startTimestamp);",
            "        segment.setTimeBucket(timeBucket);",
            "<<< var: timeBucket",
            "        segment.setIsError(BooleanUtils.booleanToValue(isError));",
            "        segment.setDataBinary(segmentObject.toByteArray());",
            "",
            "        endpointName = namingControl.formatEndpointName(serviceName, span.getOperationName());",
            "        endpointId = IDManager.EndpointID.buildId("
      ],
      "skywalking\\oap-server\\server-query-plugin\\zipkin-query-plugin\\src\\main\\java\\org\\apache\\skywalking\\oap\\query\\zipkin\\handler\\ZipkinQueryHandler.java Distance: 25 Line: 349 to 374": [
            "",
            "        final Map<String, Tuple2<Span.Builder, Integer>> spanCache = new HashMap<>();",
            "        for (Map.Entry<String, List<SpanAttachedEventRecord>> namedEntry : namedEvents.entrySet()) {",
            "            for (int i = 1; i <= namedEntry.getValue().size(); i++) {",
            "                final SpanAttachedEventRecord record = namedEntry.getValue().get(i - 1);",
            ">>> var: eventName",
            "                String eventName = record.getEvent() + (namedEntry.getValue().size() == 1 ? \"\" : \"-\" + i);",
            "                final SpanAttachedEvent event = SpanAttachedEvent.parseFrom(record.getDataBinary());",
            "",
            "                // find matched span",
            "                Tuple2<Span.Builder, Integer> spanBuilder = spanCache.get(record.getTraceSpanId());",
            "                if (spanBuilder == null) {",
            "                    Tuple2<Integer, Span> matchesSpan = spanWithIndex.stream().filter(s -> Objects.equals(s._2.id(), record.getTraceSpanId())).",
            "                        findFirst().orElse(null);",
            "                    if (matchesSpan == null) {",
            "                        continue;",
            "                    }",
            "",
            "                    // if the event is server side, then needs to change to the upstream span",
            "                    final String direction = getSpanAttachedEventTagValue(event.getTagsList(), \"data_direction\");",
            "                    final String type = getSpanAttachedEventTagValue(event.getTagsList(), \"data_type\");",
            "                    if ((\"request\".equals(type) && \"inbound\".equals(direction)) || (\"response\".equals(type) && \"outbound\".equals(direction))) {",
            "                        final String parentSpanId = matchesSpan._2.id();",
            "                        matchesSpan = spanWithIndex.stream().filter(s -> Objects.equals(s._2.parentId(), parentSpanId)",
            "                            && Objects.equals(s._2.kind(), Span.Kind.SERVER)).findFirst().orElse(matchesSpan);",
            "                    }",
            "",
            "                    spanBuilder = Tuple.of(matchesSpan._2.toBuilder(), matchesSpan._1);",
            "                    spanCache.put(record.getTraceSpanId(), spanBuilder);",
            "                }",
            "",
            "                appendEvent(spanBuilder._1, eventName, event);",
            "<<< var: eventName",
            "            }",
            "        }",
            "",
            "        // re-build modified spans",
            "        for (Map.Entry<String, Tuple2<Span.Builder, Integer>> entry : spanCache.entrySet()) {"
      ]
}